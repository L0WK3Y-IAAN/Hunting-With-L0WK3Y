# Android 08

<aside>

## **The Challenge**

This application requires a PIN code to provide you with the key. However, without knowing the PIN, you will not be able to retrieve the key.

There are two ways to get around this:

- The first way is to use [**apktool**](https://ibotpeaches.github.io/Apktool/) like you did before. **`apktool`** will extract the application's code as **`Smali`** code. Then you will be able to browse the source code in the **`Smali`** directory (it's not very intuitive, however, it's enough to solve this exercise).
- The second way is to extract the application yourself using **`unzip`**. From there, you should see a file named **`classes.dex`**. You can then use the tool [**dex2jar**](https://sourceforge.net/projects/dex2jar/) to convert the **`dex`** file to a **`jar`** file. Once this is done, you can either **`unzip`** the **`jar`** file to browse the code or use [**jd-gui**](https://github.com/java-decompiler/jd-gui/releases).

This time the code has been minimised using [**ProGuard**](https://en.wikipedia.org/wiki/ProGuard_(software)). This makes reversing the application more complex.

By inspecting the **`Smali`** code or the **`Java`** code, you should be able to find how the key has been encrypted. This time, proper encryption is used with **`AES`**. However, the key is not hardcoded and it's based on the PIN code and a string downloaded from a server. So you will need to write a small tool to brute force the decryption key based on the PIN code and the string. The PIN is composed of 4 digits and it's used as a String ("0000" instead of 0). The string and the PIN code are hashed together before being used as a key. You will need to follow the same process to test your tool and get the key to solve this challenge.

</aside>

## Understanding the Encryption Scheme

The app uses a modified AES-CBC encryption that depends on two inputs:

### Key Derivation

The encryption key is generated by concatenating a remote key with the user's PIN, then hashing it:

```java
MessageDigest messageDigest = MessageDigest.getInstance("MD5");
messageDigest.update(str3.getBytes("UTF-8"));  // Remote key
messageDigest.update(str2.getBytes("UTF-8"));  // PIN

```

So the final AES key is: `MD5(remoteKey + PIN)`

This is the critical difference from Android07, which only used `MD5(PIN)`.

### The Remote Key Fetch

Before decryption can happen, the app makes an HTTP request to fetch the remote key:

```java
HttpResponse execute = new DefaultHttpClient().execute(
    new HttpGet("https://pentesterlab.com/android08/keys.json")
);

```

The server returns a JSON object containing the key, but here's the catch: **the server validates your PIN**. If you send an invalid PIN, you get a 403 Forbidden response.

This means a naive network-based brute-force would require thousands of HTTP requests, making it slow and potentially triggering rate limits.

## The Frida Solution


Instead of making thousands of network requests, we can use Frida to bypass the network entirely by calling the decryption method directly with a hardcoded remote key.

```jsx
'use strict';

Java.perform(function () {
  // Configuration
  const PKG = 'com.pentesterlab.android08';
  const CLASS = PKG + '.a'; // The AsyncTask class containing static decryptor a(...)
  const CT_B64 = 'G38zckAufW4B9A6sywz28kzgW8CCx1UWugLUTjKlo/kwV1CVesmr0tPX/JZOW0aik0TlkrcAIZZ/G0BigUtmeg==';
  const REMOTE_KEY = '<=== P3nt3st3rL4b ===>';
  const MIN_LEN = 4;      // try 4-digit up to MAX_LEN
  const MAX_LEN = 6;      // adjust if needed

  function isPrintable(s) {
    // A basic heuristic to find readable text
    if (!s) return false;
    if (s.length < 4) return false;
    // Reject control characters except whitespace
    for (let i = 0; i < s.length; i++) {
      const c = s.charCodeAt(i);
      const isPrintableAscii = (c >= 32 && c <= 126) || c === 9 || c === 10 || c === 13;
      if (!isPrintableAscii) return false;
    }
    // Likely plaintext if it contains letters/spaces or common tokens
    const lower = s.toLowerCase();
    return /[a-z]/.test(lower) || lower.includes('key') || lower.includes('flag') || lower.includes('the ');
  }

  function* pinGenerator(minLen, maxLen) {
    for (let len = minLen; len <= maxLen; len++) {
      const max = Math.pow(10, len);
      for (let n = 0; n < max; n++) {
        yield n.toString().padStart(len, '0');
      }
    }
  }

  try {
    const Cls = Java.use(CLASS);
    // Static method signature: a(String str, String str2, String str3) -> String
    // From the code: a(ciphertext, pin, remoteKey)
    const decryptStatic = Cls.a.overload('java.lang.String', 'java.lang.String', 'java.lang.String');

    console.log('[*] Starting PIN brute-force using app decryptor...');
    console.log('[*] Ciphertext:', CT_B64);
    console.log('[*] Remote key:', REMOTE_KEY);

    let found = false;
    const startTs = Date.now();

    for (const pin of pinGenerator(MIN_LEN, MAX_LEN)) {
      let result = null;
      try {
        result = decryptStatic.call(Cls, CT_B64, pin, REMOTE_KEY);
      } catch (e) {
        // If the static method throws, continue
        result = '';
      }

      if (result && isPrintable(result)) {
        const elapsed = ((Date.now() - startTs) / 1000).toFixed(2);
        console.log('[+] Found plausible PIN:', pin, 'elapsed', elapsed, 'sec');
        console.log('[+] Plaintext:', result);
        found = true;
        break;
      }

      // Print progress periodically
      if (pin.endsWith('0000')) {
        const elapsed = ((Date.now() - startTs) / 1000).toFixed(2);
        console.log('[*] Tried PIN ~', pin, 'elapsed', elapsed, 'sec');
      }
    }

    if (!found) {
      console.log('[-] No valid PIN found in configured range. Increase MAX_LEN or widen charset.');
    }
  } catch (err) {
    console.error('[-] Failed to initialize brute-force:', err);
    console.error('[-] Ensure class name and method signature match, and you attach before decryption runs.');
  }
});

```

### Step 1: Extract the Remote Key

First, we need to know what the remote key actually is. We can capture it by intercepting the legitimate network response or simply visiting the endpoint. In this case, the key is:

```jsx
const REMOTE_KEY = '<=== P3nt3st3rL4b ===>';

```

### Step 2: Hook the Decryption Method

The app's AsyncTask class contains a static method that performs the actual decryption:

```jsx
const CLASS = 'com.pentesterlab.android08.a';
const Cls = Java.use(CLASS);
const decryptStatic = Cls.a.overload(
    'java.lang.String',  // ciphertext
    'java.lang.String',  // PIN
    'java.lang.String'   // remote key
);

```

This method signature tells us everything we need: it takes the encrypted data, a PIN, and the remote key as parameters.

### Step 3: Efficient PIN Generation

Rather than creating a massive array of all possible PINs, we use a generator function that produces PINs on-demand:

```jsx
function* pinGenerator(minLen, maxLen) {
    for (let len = minLen; len <= maxLen; len++) {
        const max = Math.pow(10, len);
        for (let n = 0; n < max; n++) {
            yield n.toString().padStart(len, '0');
        }
    }
}

```

This iterates through 4-digit PINs (0000-9999), then 5-digit, then 6-digit if needed. It's memory-efficient since it only generates one PIN at a time.

### Step 4: The Brute-Force Loop

Now we tie it all together:

```jsx
const CT_B64 = 'G38zckAufW4B9A6sywz28kzgW8CCx1UWugLUTjKlo/k...'; // The encrypted flag

for (const pin of pinGenerator(MIN_LEN, MAX_LEN)) {
    try {
        result = decryptStatic.call(Cls, CT_B64, pin, REMOTE_KEY);

        if (result && isPrintable(result)) {
            console.log('[+] Found plausible PIN:', pin);
            console.log('[+] Plaintext:', result);
            break;
        }
    } catch (e) {
        // Decryption failed, continue
    }
}

```

For each PIN candidate, we:

1. Call the decrypt method directly with our hardcoded values
2. Check if the result is readable ASCII text
3. Stop when we find something that looks like a flag

### The Printable Check

Not every decryption attempt will produce garbage, some will produce binary data or malformed strings. We filter these out:

```jsx
function isPrintable(s) {
    if (!s || s.length < 4) return false;

    let printableCount = 0;
    for (let i = 0; i < s.length; i++) {
        const code = s.charCodeAt(i);
        if ((code >= 32 && code <= 126) || code === 9 || code === 10 || code === 13) {
            printableCount++;
        }
    }

    return (printableCount / s.length) > 0.8;
}

```

This ensures we only stop when the decrypted text is at least 80% readable ASCII characters.



Challenge 8 demonstrates that even when an app implements server-side validation, local brute-forcing is still possible if the decryption logic is accessible on the client. The network dependency becomes irrelevant once you extract the remote key, Frida lets you call the app's methods directly, turning what should be a slow network-bound attack into a blazing-fast local operation.


![image.png](Android%208/image.png)
---
<div class="banner-container">
        <div class="left-panel">
            <div class="card">
                <h2>Let's Connect!</h2>
                <div class="social-links">
                    <a href="https://github.com/L0WK3Y-IAAN" target="_blank">
                        <img src="https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white" alt="GitHub">
                    </a>
                    <a href="https://www.linkedin.com/in/iaansec/" target="_blank">
                        <img src="https://img.shields.io/badge/LinkedIn-0077B5?style=for-the-badge&logo=linkedin&logoColor=white" alt="LinkedIn">
                    </a>
                </div>
            </div>
        </div>
    </div>
