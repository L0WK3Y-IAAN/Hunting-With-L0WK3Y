# Android 07

<aside>

## **The Challenge**

This application requires a PIN code to provide you with the key. However, without knowing the PIN, you will not be able to retrieve the key.

There are two ways to get around this:

- The first way is to use [**apktool**](https://ibotpeaches.github.io/Apktool/) like you did before. **`apktool`** will extract the application's code as **`Smali`** code. Then you will be able to browse the source code in the **`Smali`** directory (it's not very intuitive, however, it's enough to solve this exercise).
- The second way is to extract the application yourself using **`unzip`**. From there, you should see a file named **`classes.dex`**. You can then use the tool [**dex2jar**](https://sourceforge.net/projects/dex2jar/) to convert the **`dex`** file to a **`jar`** file. Once this is done, you can either **`unzip`** the **`jar`** file to browse the code or use [**jd-gui**](https://github.com/java-decompiler/jd-gui/releases).

This time the code has been minimised using [**ProGuard**](https://en.wikipedia.org/wiki/ProGuard_(software)). This makes reversing the application more complex.

By inspecting the **`Smali`** code or the **`Java`** code, you should be able to find how the key has been "encrypted". This time, proper encryption is used with **`AES`**. However, the key is not hardcoded and it's based on the PIN code, so you will need to write a small tool to brute force the decryption key, based on the PIN. The PIN is composed of 4 digits, used as a String ("0000" instead of 0), and it's hashed before being used as a key. You will need to follow the same process to test your tool and get the key to solve this challenge.

</aside>

## Understanding the Encryption

Let's break down what the app actually does when you enter a PIN.

### The Decryption Call

The app displays the decrypted result with this line:

```java
a("The key is: \n" + a.a("ED1nf3uLW4Hkwr1aGw+NpN5sgcRMPCFuk0XgtW181m4o6d0Ml3D/j6h1NSyOh4dbcGsbK6rcZOUyzHxWVb4QkA",
    getIntent().getExtras().getString("pin")));

```

This calls the decryption method `a.a()` with:

- The Base64-encoded encrypted flag
- The PIN that the user entered (passed via Intent extras)

### How the Decryption Works

The decryption method follows a standard AES-CBC pattern with one critical detail: **the encryption key is just `MD5(PIN)`**.

### Step 1: Decode and Extract the IV

```java
byte[] decode = Base64.decode(str, 0);

byte[] bArr2 = new byte[16];
System.arraycopy(decode, 0, bArr2, 0, bArr2.length);
IvParameterSpec ivParameterSpec = new IvParameterSpec(bArr2);

```

The first 16 bytes of the decoded data are the Initialization Vector (IV) for AES-CBC mode.

### Step 2: Extract the Ciphertext

```java
int length = decode.length - 16;
byte[] bArr3 = new byte[length];
System.arraycopy(decode, 16, bArr3, 0, length);

```

Everything after the IV is the actual encrypted message.

### Step 3: Derive the Key from the PIN

```java
MessageDigest messageDigest = MessageDigest.getInstance("MD5");
messageDigest.update(str2.getBytes("UTF-8"));

byte[] bArr4 = new byte[16];
System.arraycopy(messageDigest.digest(), 0, bArr4, 0, bArr4.length);
SecretKeySpec secretKeySpec = new SecretKeySpec(bArr4, "AES");

```

Here's the vulnerability: the app simply hashes the PIN with MD5 to create a 16-byte AES key. Since the PIN is only 4 digits (10,000 possibilities), this is trivial to brute-force.

### Step 4: Decrypt

```java
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
cipher.init(2, secretKeySpec, ivParameterSpec);
return new String(cipher.doFinal(bArr3));

```

Standard AES-CBC decryption with PKCS5 padding.

## The Frida Solution

```java
Java.perform(function() {
    console.log("[*] Finding printable flag...\n");
    
    var DecryptClass = Java.use("com.pentesterlab.android07.a");
    var encryptedData = "ED1nf3uLW4Hkwr1aGw+NpN5sgcRMPCFuk0XgtW181m4o6d0Ml3D/j6h1NSyOh4dbcGsbK6rcZOUyzHxWVb4QkA";
    
    function isPrintable(str) {
        if (!str || str.length === 0) return false;
        var printable = 0;
        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if ((c >= 32 && c <= 126) || c === 9 || c === 10 || c === 13) printable++;
        }
        return (printable / str.length) > 0.8;
    }
    
    for (var i = 0; i <= 9999; i++) {
        try {
            var pin = ("0000" + i).slice(-4);
            var result = DecryptClass.a(encryptedData, pin);
            
            if (result && result.length > 0 && isPrintable(result)) {
                console.log("[+] PIN: " + pin);
                console.log("[+] FLAG: " + result);
                break;
            }
        } catch (e) {}
        
        if (i % 500 === 0) console.log("[*] Tested: " + i);
    }
});

```

Instead of reimplementing the entire encryption scheme, we can use Frida to call the app's own decryption method thousands of times until we find the correct PIN.

### Setting Up the Hook

First, we hook into the decryption class:

```jsx
Java.perform(function() {
    var DecryptClass = Java.use("com.pentesterlab.android07.a");
    var encryptedData = "ED1nf3uLW4Hkwr1aGw+NpN5sgcRMPCFuk0XgtW181m4o6d0Ml3D/j6h1NSyOh4dbcGsbK6rcZOUyzHxWVb4QkA";

```

We target class `a` (obfuscated by ProGuard) and store the encrypted flag that we extracted from the app's code.

### Filtering Valid Results

Not every decryption attempt will succeed, most will produce garbage or throw exceptions. We need to identify when we've found the real flag:

```jsx
function isPrintable(str) {
    if (!str || str.length === 0) return false;
    var printable = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if ((c >= 32 && c <= 126) || c === 9 || c === 10 || c === 13) printable++;
    }
    return (printable / str.length) > 0.8;
}

```

This function checks if at least 80% of the characters in the decrypted string are readable ASCII. Real flags contain letters and words, not random binary data.

### The Brute-Force Loop

Now we iterate through all possible PINs:

```jsx
for (var i = 0; i <= 9999; i++) {
    try {
        var pin = ("0000" + i).slice(-4);
        var result = DecryptClass.a(encryptedData, pin);

        if (result && result.length > 0 && isPrintable(result)) {
            console.log("[+] PIN: " + pin);
            console.log("[+] FLAG: " + result);
            break;
        }
    } catch (e) {}

    if (i % 500 === 0) console.log("[*] Tested: " + i);
}

```

For each number from 0 to 9999:

1. Format it as a zero-padded 4-digit string (`"0000"`, `"0001"`, etc.)
2. Call the app's decrypt method directly
3. Check if the result looks like readable text
4. Stop immediately when we find it

The `try-catch` block silently handles decryption failures (wrong PINs that produce invalid padding or corrupted output).

### Progress Tracking

Every 500 attempts, the script prints a progress update so you know it's working:

```jsx
if (i % 500 === 0) console.log("[*] Tested: " + i);

```

Android07 demonstrates a fundamental weakness in mobile app security: **deriving encryption keys from weak user input**. A 4-digit PIN has only 10,000 possible combinations, and even with proper AES encryption, MD5 hashing, and CBC mode, it can be cracked in seconds with dynamic instrumentation.

The lesson? Never use short PINs as the sole basis for encryption keys. Use proper key derivation functions (like PBKDF2 or Argon2) with high iteration counts, or better yet, use hardware-backed keystores that prevent direct access to cryptographic operations.

---

![image.png](Android%207/image.png)